name: Build and Release

on:
  push:
    branches: [master]
    tags:
      - "v*"
  pull_request:
    branches: [master]
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-latest

    env:
      Solution_Name: GlyCounter/GlyCounter.sln
      Configuration: Release
      Project_Path: GlyCounter/GlyCounter/GlyCounter.csproj
      Package_Directory: ./package
      Release_Directory: ./Releases

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: 9.0.x # Using .NET 9 as decided previously

      - name: Calculate version
        id: version
        shell: pwsh
        run: |
          $commitCount = git rev-list --count HEAD
          $shortSha = git rev-parse --short HEAD
          $baseVersion = "0.0" 
          $versionString = "$baseVersion.$commitCount"
          $fullVersion = "$versionString+$shortSha"
          $isTagPush = $env:GITHUB_REF.StartsWith('refs/tags/v')
          if ($isTagPush) {
            $tagVersion = $env:GITHUB_REF.Replace('refs/tags/v', '')
            if ($tagVersion -match '-') { $versionString = $tagVersion.Split('-')[0] } 
            else { $versionString = $tagVersion }
            $versionParts = $versionString.Split('.')
            while ($versionParts.Length -lt 3) { $versionParts += "0" }
            $versionString = $versionParts -join '.'
            $fullVersion = $versionString
          }
          echo "VERSION=$versionString" >> $env:GITHUB_OUTPUT
          echo "FULL_VERSION=$fullVersion" >> $env:GITHUB_OUTPUT
          $csprojPath = $env:Project_Path
          if (Test-Path $csprojPath) {
            $csproj = Get-Content $csprojPath -Raw
            $assemblyFileVersion = $versionString
            if ($assemblyFileVersion.Split('.').Length -lt 3) { $assemblyFileVersion = "$assemblyFileVersion.0" }
            $csproj = $csproj -replace '<Version>.*?</Version>', "<Version>$versionString</Version>"
            $csproj = $csproj -replace '<AssemblyVersion>.*?</AssemblyVersion>', "<AssemblyVersion>$assemblyFileVersion</AssemblyVersion>"
            $csproj = $csproj -replace '<FileVersion>.*?</FileVersion>', "<FileVersion>$assemblyFileVersion</FileVersion>"
            Set-Content $csprojPath $csproj
          } else { Write-Error "Could not find csproj at $csprojPath"; exit 1 }

      - name: Restore dependencies
        run: dotnet restore $env:Solution_Name

      - name: Build
        run: dotnet build $env:Solution_Name --configuration $env:Configuration --no-restore

      - name: Test
        run: dotnet test $env:Solution_Name --configuration $env:Configuration --no-build --verbosity normal

      - name: Publish Application Executable
        run: |
          dotnet publish $env:Project_Path --configuration $env:Configuration --output ./publish --no-build /p:PublishSingleFile=true /p:SelfContained=true /p:RuntimeIdentifier=win-x64 /p:IncludeNativeLibrariesForSelfExtract=true /p:EnableCompressionInSingleFile=true
          if (-not (Test-Path "./publish/GlyCounter.exe")) { Write-Host "ERROR: GlyCounter.exe not found after publish."; exit 1 }
        shell: pwsh

      - name: Pack into NuPkg for Squirrel
        run: dotnet pack $env:Project_Path --configuration $env:Configuration --output $env:Package_Directory --no-build /p:Version=${{ steps.version.outputs.VERSION }} /p:PackageId=GlyCounter

      - name: Verify NuPkg Creation
        shell: pwsh
        run: |
          $nupkgPath = Join-Path $env:Package_Directory "GlyCounter.${{ steps.version.outputs.VERSION }}.nupkg"
          if (-not (Test-Path $nupkgPath)) { Write-Host "ERROR: NuGet package not found at $nupkgPath"; exit 1 }
          Write-Host "Successfully created NuGet package: $nupkgPath"

      - name: Setup NuGet CLI
        uses: nuget/setup-nuget@v2

      - name: Install Squirrel.Windows package locally
        run: nuget install squirrel.windows -Version 2.0.1 -OutputDirectory ./external_packages -ExcludeVersion -NonInteractive
        # This downloads and extracts the package to ./external_packages/squirrel.windows/

      - name: Verify Squirrel.exe exists
        shell: pwsh
        run: |
          $squirrelPath = "./external_packages/squirrel.windows/tools/Squirrel.exe"
          if (-not (Test-Path $squirrelPath)) { 
              Write-Host "Listing contents of ./external_packages/squirrel.windows/tools/:"
              Get-ChildItem -Path "./external_packages/squirrel.windows/tools/" -Recurse -ErrorAction SilentlyContinue | ForEach-Object { Write-Host $_.FullName }
              Write-Error "Squirrel.exe not found at expected path: $squirrelPath. Check extraction path."
              exit 1
          }
          Write-Host "Found Squirrel.exe at $squirrelPath"

      - name: Run Squirrel Releasify
        run: ./external_packages/squirrel.windows/tools/squirrel.exe --releasify ${{ env.Package_Directory }}/GlyCounter.${{ steps.version.outputs.VERSION }}.nupkg --releaseDir ${{ env.Release_Directory }}
        shell: pwsh

      - name: List files in Releases directory after Squirrel
        run: |
          Write-Host "Contents of Releases directory ($($env:Release_Directory)) after Squirrel:"
          Get-ChildItem -Path $env:Release_Directory -Recurse | ForEach-Object { Write-Host $_.FullName }
        shell: pwsh

      - name: Create Release
        if: startsWith(github.ref, 'refs/tags/v')
        uses: softprops/action-gh-release@v1
        with:
          name: GlyCounter ${{ steps.version.outputs.VERSION }}
          tag_name: ${{ github.ref }}
          draft: false
          prerelease: false
          files: |
            ${{ env.Release_Directory }}/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
