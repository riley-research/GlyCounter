name: Build and Release

on:
  push:
    branches: [ master ]
    tags:
      - 'v*'
  pull_request:
    branches: [ master ]
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-latest
    
    env:
      Solution_Name: GlyCounter/GlyCounter.sln
      Configuration: Release
      
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0 # Fetch all history for version calculation

    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: 8.0.x

    - name: Calculate version
      id: version
      shell: pwsh
      run: |
        $commitCount = git rev-list --count HEAD
        $shortSha = git rev-parse --short HEAD
        $baseVersion = "1.0"
        $versionString = "$baseVersion.$commitCount"
        $fullVersion = "$versionString+$shortSha"
        
        # Check if this is a tag push
        $isTagPush = $env:GITHUB_REF.StartsWith('refs/tags/v')
        if ($isTagPush) {
          $tagVersion = $env:GITHUB_REF.Replace('refs/tags/v', '')
          # Ensure version format is major.minor.build
          if ($tagVersion -match '-') {
            # For prerelease tags like v1.0.0-test, convert to 1.0.0.0
            $versionString = $tagVersion.Split('-')[0]
            if ($versionString.Split('.').Length -lt 3) {
              $versionString = "$versionString.0"
            }
          } else {
            $versionString = $tagVersion
            if ($versionString.Split('.').Length -lt 3) {
              $versionString = "$versionString.0"
            }
          }
          $fullVersion = $versionString
        }
        
        echo "VERSION=$versionString" >> $env:GITHUB_OUTPUT
        echo "FULL_VERSION=$fullVersion" >> $env:GITHUB_OUTPUT
        
        # Update csproj with version
        $csprojPath = "GlyCounter/GlyCounter/GlyCounter.csproj"
        $csproj = Get-Content $csprojPath -Raw
        $csproj = $csproj -replace '<Version>.*?</Version>', "<Version>$versionString</Version>"
        $csproj = $csproj -replace '<AssemblyVersion>.*?</AssemblyVersion>', "<AssemblyVersion>$versionString.0</AssemblyVersion>"
        $csproj = $csproj -replace '<FileVersion>.*?</FileVersion>', "<FileVersion>$versionString.0</FileVersion>"
        Set-Content $csprojPath $csproj

    - name: Restore dependencies
      run: dotnet restore $env:Solution_Name

    - name: Build
      run: dotnet build $env:Solution_Name --configuration $env:Configuration --no-restore -p:Version=${{ steps.version.outputs.VERSION }}

    - name: Test
      run: dotnet test $env:Solution_Name --configuration $env:Configuration --no-build --verbosity normal

    - name: Publish
      run: |
        dotnet publish GlyCounter/GlyCounter/GlyCounter.csproj --configuration $env:Configuration --output ./publish /p:PublishSingleFile=true /p:SelfContained=true /p:RuntimeIdentifier=win-x64 /p:EnableCompressionInSingleFile=true /p:Version=${{ steps.version.outputs.VERSION }}
        
        # Verify the executable was created
        if (Test-Path "./publish/GlyCounter.exe") {
            Write-Host "GlyCounter.exe was successfully created"
        } else {
            Write-Host "ERROR: GlyCounter.exe was not found. Contents of publish directory:"
            Get-ChildItem -Path "./publish" -Recurse | ForEach-Object { Write-Host $_.FullName }
            exit 1
        }

    - name: Install NuGet
      uses: NuGet/setup-nuget@v1

    - name: Create NuGet Package
      run: |
        dotnet pack GlyCounter/GlyCounter/GlyCounter.csproj --configuration $env:Configuration /p:Version=${{ steps.version.outputs.VERSION }} /p:PackageId=GlyCounter --output ./nuget
        
        # Verify the package was created with the correct name
        $expectedPackage = "./nuget/GlyCounter.${{ steps.version.outputs.VERSION }}.nupkg"
        if (Test-Path $expectedPackage) {
            Write-Host "NuGet package created successfully: $expectedPackage"
        } else {
            Write-Host "Warning: Expected package not found. Listing all packages:"
            Get-ChildItem -Path "./nuget" -Filter "*.nupkg" | ForEach-Object { Write-Host $_.FullName }
        }

    - name: Create Squirrel Release
      run: |
        mkdir -p ./Releases
        
        # Create a correctly formatted nuspec file for GlyCounter
        $nuspecContent = @"
<?xml version="1.0" encoding="utf-8"?>
<package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
  <metadata>
    <id>GlyCounter</id>
    <version>${{ steps.version.outputs.VERSION }}</version>
    <title>GlyCounter</title>
    <authors>Glyco</authors>
    <description>GlyCounter: A tool for glycan analysis</description>
    <requireLicenseAcceptance>false</requireLicenseAcceptance>
  </metadata>
  <files>
    <file src="publish\**\*.*" target="lib\net45" />
  </files>
</package>
"@
        $nuspecContent | Out-File -FilePath "./GlyCounter.nuspec" -Encoding utf8
        
        # Install specific version of Squirrel.Windows
        nuget install squirrel.windows -Version 1.9.0 -OutputDirectory ./packages
        
        # Create a NuGet package from our custom nuspec
        nuget pack ./GlyCounter.nuspec -OutputDirectory ./squirrel-package
        
        # Find the Squirrel executable
        $squirrelPath = Get-ChildItem -Path ./packages -Recurse -Filter Squirrel.exe | Select-Object -First 1 -ExpandProperty FullName
        Write-Host "Found Squirrel.exe at: $squirrelPath"
        
        if (-not $squirrelPath) {
            Write-Error "Could not find Squirrel.exe in packages directory"
            Get-ChildItem -Path ./packages -Recurse
            exit 1
        }
        
        # Find our custom NuGet package
        $nupkgPath = Get-ChildItem -Path ./squirrel-package -Filter *.nupkg | Select-Object -First 1 -ExpandProperty FullName
        if (-not $nupkgPath) {
            Write-Error "Could not find nuget package in squirrel-package directory"
            exit 1
        }
        Write-Host "Using NuGet package: $nupkgPath"
        
        # Run Squirrel with detailed output
        Write-Host "Running Squirrel to create installation package..."
        & $squirrelPath --releasify $nupkgPath --releaseDir=./Releases --no-msi
        
        # Check if Setup.exe was created
        $setupPath = Join-Path -Path "./Releases" -ChildPath "Setup.exe" 
        if (Test-Path $setupPath) {
            Write-Host "Setup.exe created successfully at: $setupPath"
        } else {
            Write-Error "Failed to create Setup.exe"
            Get-ChildItem -Path "./Releases" -Recurse | ForEach-Object { Write-Host $_.FullName }
            exit 1
        }

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: GlyCounter-${{ steps.version.outputs.VERSION }}
        path: |
          ./publish/**/*
          ./Releases/**/*
          
    - name: List files in Releases directory
      run: |
        Write-Host "Contents of Releases directory:"
        Get-ChildItem -Path "./Releases" -Recurse | ForEach-Object { Write-Host $_.FullName }

    # Only create a release if this is a tag push
    - name: Create Release
      if: startsWith(github.ref, 'refs/tags/v')
      uses: softprops/action-gh-release@v1
      with:
        name: GlyCounter ${{ steps.version.outputs.VERSION }}
        draft: false
        prerelease: false
        files: |
          ./publish/GlyCounter.exe
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
